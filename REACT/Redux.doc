REDUX
	URL:
		- http://redux.js.org/
		- https://egghead.io/courses/getting-started-with-redux
		- https://egghead.io/courses/building-react-applications-with-idiomatic-redux
	
	- Redux provides state, and React produces view to that state
	- Redux helps maintain the state
	- Redux is a state container
	- Redux centralizes all of the data in to one object, which we refere to as STATE. This APPLICATION LEVEL STATE, not the compoent state in React.
		Redux state is big object that contains all data.
		
Redux Object
	- import redux from 'redux'
	- Redux API:
			- redux.applyMiddleware
			- redux.bindActionCreators
			- redux.combineReducers(reducers)
					Example:
						let reducer = redux.combineReducers({
							name: nameReducer,
							hobbies: hobbiesReducer,
							movieReducer: moviesReducer,
							map: mapReducer
					});
			- redux.compose
			- redux.createStore

Reducer 
	- a pure function takes a current state and action, and returns a new state
	- a function that returns a piece of a application state. Because application can have many different pieces of state, we can have many 
		reducers.Example: list of all books, currently selected book,...
	- Reducer can have two arguments: 
				state - state argument is not application state, only the state this reducer is responsible for(it's the same state that is passed)
				action - Reducers is called when action occures.

		If we don't care about the action, just back the state back through
		Example in JS:
			//application state - generated by reducers
			{
				books: [{ title: "Some title" }, { title: "JavaScript" }], //Books reducers
				activeBook: { title: "Javascript: The Good Parts" } // Active book reducer
			}
			
	- never mutate(change) state in reducer

Two Types of Components on Redux:
	Container - a React component that has a direct connection to the state managed by Redux
	Normal Component - a React component that shows stuff 
	
Connect
	- function
	- Connects a React component to a Redux store.
		It does not modify the component class passed to it. Instead, it returns a new, connected component class, for you to use.
	- Syntax:
				connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])	
	-	Two important things about connect function:
			1) If state ever change this container will instantely re-render with the new list of books
			2) object inside of state object in GLUE function will be assigned to this.props;
				 Example:
						function mapStateToProps(state){
							//Whatever is returned will show up as props
							//inside of BookList
							return {
								books: state.books
							};
						}

						//render(){
							this.props.books
						}

Action Creator 
	- function that returns an action.
	- functions that take all of the parameters nedded for creating a actions
	- Action - object that flows though all reducers. Action always hase key "type". Reducers can use that action to produce a different value 
							for particular piece of state
		Example:
				export function selectBook(book){
					// selectBook is an ActionCreator, it needs to return an action,
					// an object with a type property
					// payload - useful piece of information
					return {
						type: 'BOOK_SELECTED',
						payload: book
					};
				}
				
		Example:
				rateCourse(rating){		
					// { type: RATE_COURSE, rating: rating } - action
					return { type: RATE_COURSE, rating: rating };
				}
				
	- if action creator(in separate file) need to call dispatch, using middleware - redux-thunk(https://github.com/gaearon/redux-thunk):
			npm install --save-dev redux-thunk
			
			Example:
					import thunk from 'redux-thunk'
					
					let store = redux.createStore(reducer, redux.compose(
						redux.applyMiddleware(thunk)
						window.devToolsExtension ? window.devToolsExtension() : f => f
					));


Middleware in Redux
	- applying middleware
			import ReduxPromise from 'redux-promise';

			const createStoreWithMiddleware = applyMiddleware(ReduxPromise)(createStore);

API in Redux
	- package redux-promise(npm install --save redux-promise) - Stops proccess until promise is resolved, and then continue to switch statement
	- axios - Promise based HTTP client for the browser and node.js
	
Redux
	- Redux helps maintan state of the application
	- store - "local client-side database"
	- three core principles:
			1. all application state is placed in a single immutable store(state can't be changed)
			2. actions(user action - click,...) triggers changes - only way to mutate state
			3. state are changes by pure functions - reducers. Reducer accept current state and action and returns a new state
			
	- data flows philosophy - unidirectional flow:
				 - data flows down 
				 - actions flows up
				 
	- redux concepts:
			Reducers - pure functions 
			Containers - React components that interact with state and passed down to regular components via props
			Immutability - Redux store is immutable
			
Redux flow:
	- user action - click button,...
	- action creator creates an action 
	- action - object, needs to have a "type". Example: { type: RATE_COURSE, rating: 5 }
	- action is handled by reducer - return a new state
		Example:
			function appReducer(state = defaultState, action){
				switch(action.type){
					case RATE_COURSE:
						//return new state
				}
			}
	- one the new state is returned from reducer, the store is updated and any React component that uses the data is updated
	
Store
	- creating a store:
			createStore(reducer, preloadedState, enhancer)
				reducer - pure function
			
	- creating Redux store
			let store = createStore(reducer)
	- Redux store API:
			store.dispatch(action)
			store.subscribe(listener)
			store.getState()
			store.replaceReducer(nextReducer)
	- with Redux API we CAN NOT change the state, only way to change the store is by user action
	Methods:
		store.dispatch(action) 
			- dispatch action to a store  
		
		store.subscribe(listener) 
			- listening to the changes in the state
				Example:
					store.subscribe(() => {
						let state = store.getState();
						console.log('New State: ', state);
					});
					
				Example - Resetine listener(unsubscribe):
					let listener = store.subscribe(() => {
						let state = store.getState();
						console.log('New State: ', state);
					});

					let action = { 
						type: 'CHANGE_SEARCH_TEXT',
						searchText: "Test"
					};

					store.dispatch(action);

					listener();
		
	Immutability
		- instead of changing a state object, we must return a new object that represents a application new state
		- creating a copy of object in JS:
				- Object.assign(target,...source)
					Example:
						Object.assign({}, state, {role: 'admin'}); // creates a copy of state with a role property in it
						
		- handling immutable state:
				-ES6
					- Object.assign
					- Spread operator
				- ES5
					- Lodash merge
					- Lodash extend
					- object-assign (npm)
				Libraries:
					- react-addons-update
					- Immutable.js
					
		- how to force immutability:
				- trust
				- redux-immutable-state-invariant
				- Immutable.js
				
	Reducer
		- (action,state) => new state
			function myReducer(state, action){
				// return new state based on action passed
			}
		 Example:
				// wrong - mutating state
				function myReducer(state, action){
					switch(action.type){
						case 'INCREMENT_COUNTER':
							state.counter++; // wrong
							return state;
					}
				}
				
				// wright
				function myReducer(state, action){
					switch(action.type){
						case 'INCREMENT_COUNTER':
							return ( Object.assign(
									{},
									state,
									{ counter: state.counter + 1}
								)
							);
					}
				}
			
	- reducers must be PURE function - can't produce side effects. It always returns the same values for the same arguments.
		Forbidden in reducers:
			- mutate arguments
			- perform side effects (make an API calls,...)
			- call non-pure functions( Math.rand, Date.now)
			
	- Advice: one store - multiple reducers
	- If we have multiple reducers ALL reducers are called on each dispatch. It is important to all reducers returns an attached state
		as default if type didn't match
		
	- each reducer handles its "slice" of state
							- loadingStatus
			store = - authors
							- courses

	- Tip: "write independent small reducer functions that are each responsible for updates to a specific slice of state. We call this
					pattern 'reducer composition'. A given action could be handled by all, some, or none of them."

Dan Abramov

Redux principle:
	1) state of application is represent with a single JS object. This object is called state or state tree.
		 This state contains all changes in application. 
	2) state is redundant, read-only, we can't modify it or edit. Any time we want to change state, we have to dispatch an action.
	3) action is plain JS object. Only requirement for action is to have a type property, structure of action is random.
	4) redux are pure functions
	
Pure functions:
	- returned value depends only on the values of the passed arguments. It always returns same value for same argument
	- they do not modify arguments passed to them
	- the do not have side affects (DB calls,...)

Reducer 
	- pure function
	- takes arguments: previous state and action
	- returns: new state of whole app (it doesn't actually modify state, it returns a object). New state is calculated
		based on previous state and action
	
	Example:
		const counter = (state = 0, action) => {
			switch(action.type){
				case 'INCREMENT':
					return state + 1;
				case 'INCREMENT':
					return state - 1;
				default:
					return state;
			}
		}
		
Store
	- create store
			const { createStore } = Redux;
			// or Node
			import { createStore } from 'Redux';
	- create store
			const store = createStore(counter);  // counter - reducer
	- state methods
			dispatch()
			getState()
			replaceReducer()
			subscribe()
	
			Example:
				console.log(store);		
				console.log(store.getState());		
				
	- dispatch action
			store.dispatch({ type: 'INCREMENT' });
			
	- subscribe - register a callback that redux store will call any time an action has been dispatch
	
// nastaviti: https://egghead.io/lessons/javascript-redux-avoiding-array-mutations-with-concat-slice-and-spread
	

	
	
	
	

